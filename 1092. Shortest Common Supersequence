# Shortest Common Supersequence (LeetCode 1092)

## Problem Statement
Given two strings `str1` and `str2`, return the shortest string that has both `str1` and `str2` as subsequences. If there are multiple valid strings, return any of them.

A string `s` is a subsequence of string `t` if deleting some number of characters from `t` (possibly 0) results in the string `s`.

### Example 1:
**Input:**
```plaintext
str1 = "abac"
str2 = "cab"
```
**Output:**
```plaintext
"cabac"
```
**Explanation:**
- "abac" is a subsequence of "cabac" because we can delete the first 'c'.
- "cab" is a subsequence of "cabac" because we can delete the last "ac".
- The answer provided is the shortest such string that satisfies these properties.

### Example 2:
**Input:**
```plaintext
str1 = "aaaaaaaa"
str2 = "aaaaaaaa"
```
**Output:**
```plaintext
"aaaaaaaa"
```

## Constraints
- `1 <= str1.length, str2.length <= 1000`
- `str1` and `str2` consist of lowercase English letters.

## Solution Approach
The problem is solved using **Dynamic Programming**. The key idea is to build a **DP table** that keeps track of the shortest supersequence for each prefix of `str1` and `str2`.

### Steps:
1. Use a **2D DP table** where `dp[i][j]` represents the shortest common supersequence of `str1[0..i-1]` and `str2[0..j-1]`.
2. If characters match at `str1[i-1]` and `str2[j-1]`, extend the supersequence from `dp[i-1][j-1]`.
3. If they do not match, select the shorter supersequence from either `dp[i-1][j]` or `dp[i][j-1]`.
4. Construct the shortest common supersequence using the values stored in the DP table.

## Code Implementation (Java)
```java
class Solution {
    public String shortestCommonSupersequence(String str1, String str2) {
        int str1Length = str1.length();
        int str2Length = str2.length();

        // Initialize the first row (when str1 is empty, the supersequence is str2's prefix)
        String[] prevRow = new String[str2Length + 1];
        for (int col = 0; col <= str2Length; col++) {
            prevRow[col] = str2.substring(0, col);
        }

        // Fill the DP table row by row
        for (int row = 1; row <= str1Length; row++) {
            // Initialize the first column (when str2 is empty, the supersequence is str1's prefix)
            String[] currRow = new String[str2Length + 1];
            currRow[0] = str1.substring(0, row);

            for (int col = 1; col <= str2Length; col++) {
                // If characters match, extend the supersequence from the diagonal value
                if (str1.charAt(row - 1) == str2.charAt(col - 1)) {
                    currRow[col] = prevRow[col - 1] + str1.charAt(row - 1);
                } else {
                    // If characters do not match, choose the shorter supersequence
                    String pickS1 = prevRow[col];
                    String pickS2 = currRow[col - 1];
                    currRow[col] = (pickS1.length() < pickS2.length()) ? pickS1 + str1.charAt(row - 1) : pickS2 + str2.charAt(col - 1);
                }
            }
            // Move to the next row (update previous row reference)
            prevRow = currRow;
        }
        // Return the shortest common supersequence from the last cell
        return prevRow[str2Length];
    }
}
```

## Complexity Analysis
- **Time Complexity:** `O(m * n)`, where `m` and `n` are the lengths of `str1` and `str2` respectively. We iterate through both strings and fill the DP table.
- **Space Complexity:** `O(n)`, as we use only two arrays (`prevRow` and `currRow`) instead of a full 2D table.

## Alternative Approach
Instead of storing entire strings in the DP table, we can store lengths and reconstruct the supersequence in a second pass, reducing space complexity to `O(m * n)` for DP table computation and `O(m + n)` for reconstruction.

## Edge Cases Considered
- `str1` and `str2` have completely different characters.
- `str1` and `str2` are identical.
- One of the strings is empty (edge case where the answer is the non-empty string itself).

## Summary
- The problem is solved efficiently using **dynamic programming**.
- The approach constructs the shortest common supersequence iteratively.
- The solution ensures optimal **time and space complexity**.

This method provides an elegant way to find the **Shortest Common Supersequence** efficiently!

