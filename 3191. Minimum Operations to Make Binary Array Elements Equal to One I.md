# Hi there! ðŸ‘‹

## About Me
Welcome to my GitHub profile! I am passionate about:
- ðŸš€ Aeromodelling, UAV building, and FPV drone piloting
- ðŸ’» Data Structures and Algorithms (DSA)
- ðŸ¤– Problem-solving through competitive programming
- ðŸ“š Exploring books like *The Alchemist*

## LeetCode Solutions
I enjoy solving coding problems on platforms like LeetCode. Here's a recent solution I implemented for the problem **"Minimum Operations to Make Binary Array Elements Equal to One I"**:

### Problem Statement
Given a binary array `nums`, you can flip any three consecutive elements any number of times. Return the minimum number of operations required to make all elements `1`, or `-1` if it's impossible.

### Solution in Java
```java
import java.util.*;

class Solution {
    public int minOperations(int[] nums) {
        Deque<Integer> flipQueue = new ArrayDeque<>();
        int count = 0;

        for (int i = 0; i < nums.length; i++) {
            while (!flipQueue.isEmpty() && i > flipQueue.peekFirst() + 2) {
                flipQueue.pollFirst();
            }

            if ((nums[i] + flipQueue.size()) % 2 == 0) {
                if (i + 2 >= nums.length) {
                    return -1;
                }
                count++;
                flipQueue.offerLast(i);
            }
        }

        return count;
    }
}
```

### Complexity Analysis
- **Time Complexity:** \(O(n)\)
  - We iterate through the array once, and each index is processed in constant time due to the deque operations.
  - The `while` loop removes elements from the queue in amortized \(O(1)\) time.
  - Hence, the overall time complexity is linear.

- **Space Complexity:** \(O(n)\)
  - In the worst case, the deque could store up to \(O(n)\) elements if flips are required frequently.
  - Thus, the auxiliary space usage is proportional to the input size.

## Connect With Me
If you're interested in collaborating or discussing similar topics, feel free to reach out!

Happy Coding! ðŸš€

