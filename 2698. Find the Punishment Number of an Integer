Here's the fully markdown-formatted README file for the "Punishment Number of an Integer" problem:

```markdown
# Punishment Number of an Integer

## Problem Description

The punishment number of a positive integer `n` is the sum of the squares of all integers `i` such that:

1. \( 1 \leq i \leq n \)
2. The decimal representation of \( i^2 \) can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals `i`.

### Example

```java
Solution solution = new Solution();
System.out.println(solution.punishmentNumber(10));  // Output: 182
System.out.println(solution.punishmentNumber(37));  // Output: 1478
```

### Input and Output

**Input:**
- `n`: Integer (1 <= `n` <= 1000)

**Output:**
- Integer representing the punishment number of `n`.

### Explanation

1. For `n = 10`, the punishment number is `1 + 81 + 100 = 182`.
   - `1` since \( 1^2 = 1 \)
   - `9` since \( 9^2 = 81 \), and `81` can be partitioned into `8` and `1` which sums to `9`.
   - `10` since \( 10^2 = 100 \), and `100` can be partitioned into `10` and `0` which sums to `10`.

2. For `n = 37`, the punishment number is `1 + 81 + 100 + 1296 = 1478`.

## Solution

```java
class Solution {

    public boolean findPartitions(
        int startIndex,
        int sum,
        String stringNum,
        int target,
        int[][] memo
    ) {
        if (startIndex == stringNum.length()) {
            return sum == target;
        }

        if (sum > target) return false;

        if (memo[startIndex][sum] != -1) return memo[startIndex][sum] == 1;

        boolean partitionFound = false;

        for (int currentIndex = startIndex; currentIndex < stringNum.length(); currentIndex++) {
            String currentString = stringNum.substring(startIndex, currentIndex + 1);
            int addend = Integer.parseInt(currentString);

            partitionFound = partitionFound || findPartitions(currentIndex + 1, sum + addend, stringNum, target, memo);
            if (partitionFound) {
                memo[startIndex][sum] = 1;
                return true;
            }
        }

        memo[startIndex][sum] = 0;
        return false;
    }

    public int punishmentNumber(int n) {
        int punishmentNum = 0;
        for (int currentNum = 1; currentNum <= n; currentNum++) {
            int squareNum = currentNum * currentNum;
            String stringNum = Integer.toString(squareNum);

            int[][] memoArray = new int[stringNum.length()][currentNum + 1];
            for (int[] row : memoArray) {
                java.util.Arrays.fill(row, -1);
            }

            if (findPartitions(0, 0, stringNum, currentNum, memoArray)) {
                punishmentNum += squareNum;
            }
        }
        return punishmentNum;
    }
}
```

## Complexity Analysis

### Time Complexity

- **`findPartitions` function**:
  - The time complexity of `findPartitions` is exponential in nature because it explores all possible partitions. For a given number `i`, the maximum number of digits in \( i^2 \) is about \( O(\log(i^2)) \), which simplifies to \( O(\log(i)) \).
  - The maximum number of possible partitions is \( 2^m \), where `m` is the number of digits in \( i^2 \), so the complexity for each partition check is \( O(2^m) \).
  
- **`punishmentNumber` function**:
  - We iterate through numbers from `1` to `n`, and for each number `i`, we compute its square and check all valid partitions. Since the maximum number of digits in \( i^2 \) is \( O(\log(i)) \), the overall time complexity is approximately:
    \[
    O(n \times 2^m) \quad \text{where} \quad m = O(\log(i))
    \]
    With \( n = 1000 \), this is manageable.

### Space Complexity

- **Memoization space**: For each number `i`, the space complexity is proportional to the number of digits in \( i^2 \), which is \( O(\log(i)) \). The memoization table has a space complexity of \( O(m \times k) \), where `m` is the number of digits in \( i^2 \) and `k` is the integer `i`.
- The total space complexity is \( O(n \times m) \), where `n` is the number of integers considered and `m` is the number of digits in the square of the largest number.

### Edge Cases Considered

- **Zero and large numbers**: When numbers are large, memoization ensures that calculations do not repeat unnecessarily, and the algorithm handles large inputs up to `n = 1000`.
- **Partition checks**: The solution ensures that all possible partitions of the square of a number are considered.

## Conclusion

This solution efficiently computes the punishment number of a given integer using dynamic programming with memoization, ensuring optimal time and space complexity even for larger inputs. The algorithm's design allows handling up to the maximum constraints while maintaining fast performance.
```

### Key Sections:
- **Problem Overview**: A brief explanation of the problem.
- **Example Inputs and Outputs**: Examples of input and output.
- **Solution**: The Java solution code.
- **Complexity Analysis**: A concise version of the complexity analysis.

This file will now render properly with the correct Markdown formatting when viewed on GitHub. Let me know if you need anything else!
